Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2020-10-05T20:59:22+05:30

====== 2. L7 - State Space Search contd ======
Created Monday 05 October 2020

There are two kinds state space search problems:
1. **Planning** problem - we need find the path to the goal state. e.g Solution of a rubics cube, the "Man, Goat, Lion and Cabbage" problem.
2. **Configuration** problem - we need to find a configuration which holds under given constraints. e.g N-queens problem. There's no need of a path here.
--------------------
**Approaches for planning problems**:
1. Append parents as value of the node as we go, uptill the goal node.
	{{./pasted_image.png}}
	The path is just the goal state in reversed order, we return this when we return the goal.
2. Store the node value as node pairs(current, parent). The function which reconstructs the path is called //reconstructPath//.
	{{./pasted_image001.png}}  {{./pasted_image002.png}}
	We also need a //removeSeen// which will remove any existing nodes(in OPEN or CLOSED) from the nodes  generated by the moveGen function. 
	**Note**: removeSeen is required only if we are using lists. If we are using sets, there are no duplicates by default.

	Now, while using a list, we can append the moveGen() generated list either to the head **or** the tail of the list.
	i.e OPEN = moveGen().append(OPEN) - **Stack**
	or OPEN = OPEN.append(moveGen()) - **Queue**

	**What should we choose? And how does it affect the search process?**
	To answer this, we'll observe the search tree.

	a. If we use the stack approach, we go depth first, i.e the **newest** nodes are considered, in other words 'Deepest nodes first'. Hence the name **DFS(Depth First Search)**.
		DFS reverts when it hits a dead end. Even while backtracking, it still follows the **newest first** strategy.
		{{./pasted_image003.png?width=300}} {{./pasted_image005.png?height=255}}
	b. If we used the queue approach, the algorithm would explore the nodes following the strategy **oldest first**.
		It will go in a spiral fashion, layer by layer. In other words, the search tree will be traverse the whole width of the tree before moving down. Hence the name **Breadth First Search(BFS)**
		{{./pasted_image004.png?width=300}} {{./pasted_image006.png?height=277}}
Note:
* Both the algorithms have no sense of direction, completely oblivious to the location of the goal state. This is why they are called uninformed or blind search algorithms.
--------------------
DFS vs BFS
1. Time complexity - b^{d} for both. Where b is a constant branching factor. Very pedantically DFS is slightly faster.
	{{./pasted_image008.png?width=200}}
2. Completeness(will the search end) - DFS will never reach the goal if there are infinite states(as it shoots down in one direction, impetuously). BFS is complete for infinite graphs too(assuming the goal state exists). For finite graphs both are complete.
	{{./pasted_image009.png}}
3. Quality of soln - length of the path - BFS always guarantees the shortest path. DFS is not that good.
	{{./pasted_image007.png}}
	Here DFS → SCDF
	BFS → ABG (shortest)
4. Space complexity - Size of OPEN list/set - DFS size grows linearly, BFS grows exponentially. Hence DFS has better space complexity. We ignore the CLOSED list here because some algos don't use a CLOSED list and it is mostly the same irrespective of the algo.
